local repo = "https://raw.githubusercontent.com/MoonWareV1/MoonWareHub/main/"

local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Stats = game:GetService("Stats")
local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

local Window = Library:CreateWindow({
    Title = "MoonWare",
    Footer = "Version: Roblox",
    Icon = 118885599201447,
    NotifySide = "Left",
    ShowCustomCursor = true,
})

local Tabs = {
    Info = Window:AddTab("Information", "info"),
    Main = Window:AddTab("Main", "user"),
    Weapons = Window:AddTab("Weapon", "shield-user"),
    ["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox("Movement", "person-standing")
local RightGroupBox = Tabs.Main:AddRightGroupbox("MISC", "plus")
local Groupbox = Tabs.Weapons:AddLeftGroupbox("AimBot", "crosshair")
local Status = Tabs.Info:AddLeftGroupbox("Status", "chart-bar")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")

-- WalkSpeed Slider
LeftGroupBox:AddSlider("WalkSpeedSlider", {
    Text = "WalkSpeed",
    Default = 16,  -- Roblox default walkspeed
    Min = 8,
    Max = 200,
    Rounding = 1,
    Callback = function(value)
        if Humanoid then
            Humanoid.WalkSpeed = value
        end
        print("WalkSpeed set to:", value)
    end,
    Tooltip = "Walking speed",
})

Options.WalkSpeedSlider:SetValue(16) -- default value

-- WalkSpeed Reset Button
LeftGroupBox:AddButton({
    Text = "Reset WalkSpeed",
    Func = function()
        if Humanoid then
            Humanoid.WalkSpeed = 16
        end
        Options.WalkSpeedSlider:SetValue(16)
        print("WalkSpeed reset to default (16)")
    end,
    Tooltip = "Reset WalkSpeed",
})

-- JumpPower Slider
LeftGroupBox:AddSlider("JumpPowerSlider", {
    Text = "Jump Power",
    Default = 50, -- Roblox default jump power
    Min = 20,
    Max = 200,
    Rounding = 1,
    Callback = function(value)
        if Humanoid then
            Humanoid.JumpPower = value
        end
        print("JumpPower set to:", value)
    end,
    Tooltip = "Jump power",
})

Options.JumpPowerSlider:SetValue(50) -- default value

-- JumpPower Reset Button
LeftGroupBox:AddButton({
    Text = "Reset JumpPower",
    Func = function()
        if Humanoid then
            Humanoid.JumpPower = 50
        end
        Options.JumpPowerSlider:SetValue(50)
        print("JumpPower reset to default (50)")
    end,
    Tooltip = "Reset JumpPower",
})

LeftGroupBox:AddDivider()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Variables
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

local flying = false
local flySpeed = 50  -- default speed, will be controlled by slider

local bodyVelocity
local bodyGyro

-- Update character references on respawn
local function setupCharacterRefs(newCharacter)
    character = newCharacter
    hrp = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
end

-- Smooth damping helper (not currently used but keep if you want to add smoothness)
local function damp(current, target, speed, dt)
    return current + (target - current) * math.clamp(speed * dt, 0, 1)
end

-- Fly toggle logic
local function toggleFly(state)
    flying = state

    if flying then
        if bodyVelocity then bodyVelocity:Destroy() end
        if bodyGyro then bodyGyro:Destroy() end

        bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
        bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        bodyVelocity.Parent = hrp

        bodyGyro = Instance.new("BodyGyro")
        bodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
        bodyGyro.P = 2000
        bodyGyro.D = 100
        bodyGyro.CFrame = workspace.CurrentCamera.CFrame
        bodyGyro.Parent = hrp

        humanoid.PlatformStand = true

        RunService:BindToRenderStep("FlyMovement", Enum.RenderPriority.Character.Value, function(dt)
            if not flying then return end

            local moveDir = Vector3.new(0, 0, 0)
            local camCF = workspace.CurrentCamera.CFrame

            if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveDir += camCF.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveDir -= camCF.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveDir -= camCF.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveDir += camCF.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveDir += Vector3.new(0,1,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveDir -= Vector3.new(0,1,0) end

            -- Normalize movement direction
            if moveDir.Magnitude > 0 then
                moveDir = moveDir.Unit
                bodyVelocity.Velocity = moveDir * flySpeed
            else
                bodyVelocity.Velocity = Vector3.new(0,0,0)
            end

            -- Camera follow rotation
            bodyGyro.CFrame = camCF
        end)

    else
        if bodyVelocity then
            bodyVelocity:Destroy()
            bodyVelocity = nil
        end

        if bodyGyro then
            bodyGyro:Destroy()
            bodyGyro = nil
        end

        humanoid.PlatformStand = false
        RunService:UnbindFromRenderStep("FlyMovement")
    end
end

-- Add slider for controlling fly speed
local FlySpeedSlider = LeftGroupBox:AddSlider("FlySpeed", {
    Text = "Fly Speed",
    Default = flySpeed,
    Min = 10,
    Max = 200,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        flySpeed = value
    end,
})

-- Fly toggle UI element
local FlyToggle = LeftGroupBox:AddToggle("FlyEnabled", {
    Text = "Enable Flying",
    Default = false,
    Tooltip = "Flight mode",
    Callback = function(state)
        toggleFly(state)
    end,
})

-- Fly keybind toggle
local FlyKey = FlyToggle:AddKeyPicker("FlyKeybind", {
    Text = "Fly Toggle Key",
    Default = "",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function(value)
        FlyToggle:SetValue(value)
    end,
    ChangedCallback = function(newKey)
        print("Fly key changed to:", newKey)
    end,
})

LeftGroupBox:AddDivider()

-- Re-bind character references and maintain flying on respawn
localPlayer.CharacterAdded:Connect(function(newCharacter)
    setupCharacterRefs(newCharacter)

    if flying then
        -- Re-enable fly on respawn
        toggleFly(false)  -- turn off first just in case
        task.wait(0.1)
        toggleFly(true)
    end
end)

-- Initial setup call in case character already loaded
setupCharacterRefs(character)

-- Optional: support "Hold" mode for keybind (your existing loop)
task.spawn(function()
    while true do
        task.wait(0.1)

        local state = Options.FlyKeybind:GetState()
        local mode = Options.FlyKeybind.Value[2]

        if mode == "Hold" then
            if state and not flying then
                toggleFly(true)
                Options.FlyEnabled:SetValue(true)
            elseif not state and flying then
                toggleFly(false)
                Options.FlyEnabled:SetValue(false)
            end
        end
    end
end)


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local noclipEnabled = false
local noclipConnection = nil
local noclipDebounce = false

local function cleanupNoclip(character)
    if not character then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")

    if hrp then
        -- Lift the character slightly to avoid clipping into the floor
        hrp.CFrame = hrp.CFrame + Vector3.new(0, 3, 0)
    end

    -- Gradually restore collisions on parts
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
            task.wait(0.01)  -- tiny delay to smooth physics update
        end
    end
end

local function toggleNoclip(state)
    if noclipDebounce then return end
    noclipDebounce = true

    noclipEnabled = state
    if noclipEnabled then
        print("Noclip Enabled")
        noclipConnection = RunService.Stepped:Connect(function()
            local character = LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        print("Noclip Disabled")
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end

        cleanupNoclip(LocalPlayer.Character)
    end

    task.delay(0.2, function()
        noclipDebounce = false
    end)
end

LocalPlayer.CharacterAdded:Connect(function(character)
    if not noclipEnabled then
        -- Just in case, reset collisions when character respawns
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end)

local NoclipToggle = LeftGroupBox:AddToggle("NoclipEnabled", {
    Text = "Enable Noclip",
    Default = false,
    Tooltip = "Walk through walls",
    Callback = function(state)
        toggleNoclip(state)
    end
})

local NoclipKeybind = NoclipToggle:AddKeyPicker("NoclipKeybind", {
    Text = "Noclip Toggle Key",
    Default = "",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function(value)
        NoclipToggle:SetValue(value)
    end,
    ChangedCallback = function(newKey)
        print("Noclip key changed to:", newKey)
    end
})


Library:OnUnload(function()
    if noclipConnection then
        noclipConnection:Disconnect()
    end
    print("Unloaded!")
end)

Library:OnUnload(function()
    print("Unloaded!")
end)

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Player references
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- INF JUMP
local infJumpEnabled = false

local function onJumpRequest()
    if infJumpEnabled then
        localPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end

-- TELEPORT TO MOUSE
local teleportEnabled = false
local teleportKey = Enum.KeyCode.T -- default key for teleport toggle (you can change or add keypicker later)

local function teleportToMouse()
    local mouse = localPlayer:GetMouse()
    local targetPos = mouse.Hit.Position

    -- Raycast downwards to find a safe ground position to teleport to
    local rayOrigin = targetPos + Vector3.new(0, 50, 0)
    local rayDirection = Vector3.new(0, -100, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {localPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local rayResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    if rayResult then
        local safePos = rayResult.Position + Vector3.new(0, 3, 0) -- teleport a bit above ground
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(safePos)
        end
    end
end

-- UI toggles for Infinite Jump
local InfJumpToggle = LeftGroupBox:AddToggle("InfJumpEnabled", {
    Text = "Enable Infinite Jump",
    Default = false,
    Tooltip = "inf jumping",
    Callback = function(state)
        infJumpEnabled = state
    end
})

-- UI toggles for Teleport to Mouse
local TeleportToggle = LeftGroupBox:AddToggle("TeleportEnabled", {
    Text = "Enable Teleport to Mouse",
    Default = false,
    Tooltip = "teleport to mouse",
    Callback = function(state)
        teleportEnabled = state
    end
})

local TeleportKeybind = TeleportToggle:AddKeyPicker("TeleportKeybind", {
    Text = "Teleport Toggle Key",
    Default = "",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function(value)
        -- nothing extra needed here
    end,
    ChangedCallback = function(newKey)
        teleportKey = Enum.KeyCode[newKey] or Enum.KeyCode.T
    end
})

-- Connections
UserInputService.JumpRequest:Connect(function()
    if infJumpEnabled then
        onJumpRequest()
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if teleportEnabled and input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == teleportKey then
            teleportToMouse()
        end
    end
end)

-- Character reset handling (optional but good practice)
localPlayer.CharacterAdded:Connect(function(char)
    character = char
    humanoid = character:WaitForChild("Humanoid")
    hrp = character:WaitForChild("HumanoidRootPart")
end)

-- Anti-AFK
local VirtualUser = game:GetService("VirtualUser")

RightGroupBox:AddToggle("AntiAFK", {
    Text = "Anti AFK",
    Default = false,
    Tooltip = "Prevents you from getting kicked for being idle",
    Callback = function(state)
        if state then
            local connection
            connection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
            Options.AntiAFK.Connection = connection
        else
            if Options.AntiAFK.Connection then
                Options.AntiAFK.Connection:Disconnect()
                Options.AntiAFK.Connection = nil
            end
        end
    end
})

-- Player Teleportation dropdown and button
local playerList = {}
local playerDropdown = RightGroupBox:AddDropdown("PlayerTeleportDropdown", {
    Values = {},
    Default = nil,
    Text = "Select Player to Teleport",
    Tooltip = "Choose a player to teleport to",
    Callback = function(value)
        -- value will be the player's name
    end,
})

RightGroupBox:AddButton({
    Text = "Teleport to Player",
    Tooltip = "Teleport to selected player",
    Func = function()
        local selectedPlayerName = Options.PlayerTeleportDropdown.Value
        if not selectedPlayerName then
            Library:Notify("No Player Selected", "Please select a player first.")
            return
        end

        local targetPlayer = Players:FindFirstChild(selectedPlayerName)
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = targetPlayer.Character.HumanoidRootPart
            if character and hrp then
                hrp = hrp or targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                character.HumanoidRootPart.CFrame = hrp.CFrame + Vector3.new(0, 3, 0)
                Library:Notify("Teleported!", "Teleported to player: " .. selectedPlayerName)
            end
        else
            Library:Notify("Player Not Found", "The selected player is not available for teleport.")
        end
    end,
})

-- Update player list without lag on join/leave and periodically
local function updatePlayerDropdown()
    local names = {}
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= localPlayer then
            table.insert(names, plr.Name)
        end
    end
    table.sort(names)
    playerDropdown:SetValues(names)
end

Players.PlayerAdded:Connect(function()
    task.wait(1) -- small delay to let player fully load
    updatePlayerDropdown()
end)

Players.PlayerRemoving:Connect(function()
    task.wait(0.5)
    updatePlayerDropdown()
end)

-- Initial populate
updatePlayerDropdown()

-- Place Teleportation (example places, add your own)
local placeTeleportTable = {
    {Name = "Spawn", PlaceId = game.PlaceId},
    {Name = "Example Place 1", PlaceId = 123456789},
    {Name = "Example Place 2", PlaceId = 987654321},
}

local placeNames = {}
for _, place in ipairs(placeTeleportTable) do
    table.insert(placeNames, place.Name)
end

local placeDropdown = RightGroupBox:AddDropdown("PlaceTeleportDropdown", {
    Values = placeNames,
    Default = placeNames[1],
    Text = "Select Place to Teleport",
    Tooltip = "Choose a place to teleport",
})

RightGroupBox:AddButton({
    Text = "Teleport to Place",
    Tooltip = "Teleport to selected place",
    Func = function()
        local selectedPlaceName = Options.PlaceTeleportDropdown.Value
        if not selectedPlaceName then
            Library:Notify("No Place Selected", "Please select a place first.")
            return
        end

        for _, place in ipairs(placeTeleportTable) do
            if place.Name == selectedPlaceName then
                -- Teleport the player
                local TeleportService = game:GetService("TeleportService")
                TeleportService:Teleport(place.PlaceId, localPlayer)
                return
            end
        end

        Library:Notify("Place Not Found", "The selected place was not found.")
    end,
})

local camModsEnabled = false
local camFOV = 70

-- Cam Mods toggle
RightGroupBox:AddToggle("CamModsToggle", {
    Text = "Cam Mods",
    Default = false,
    Tooltip = "Camera modifications",
    Callback = function(state)
        camModsEnabled = state
        if not camModsEnabled then
            -- Reset FOV to default 70 when disabled
            workspace.CurrentCamera.FieldOfView = 70
            Options.CamFOVSlider:SetDisabled(true)
        else
            -- Enable slider when cam mods enabled
            Options.CamFOVSlider:SetDisabled(false)
            workspace.CurrentCamera.FieldOfView = camFOV
        end
    end,
})

-- Cam FOV slider (70 to 150)
RightGroupBox:AddSlider("CamFOVSlider", {
    Text = "Camera FOV",
    Default = 70,
    Min = 70,
    Max = 150,
    Rounding = 0,
    Tooltip = "Adjust the camera field of view",
    Callback = function(value)
        camFOV = value
        if camModsEnabled then
            workspace.CurrentCamera.FieldOfView = camFOV
        end
    end,
    Disabled = true, -- disabled by default until toggle enabled
})


-- Invisibility toggle
local function setCharacterVisibility(state)
    if not character then return end
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.Transparency = state and 1 or 0
            -- Special case for hair/accessories: also disable them
            if part.Name:lower():find("hair") or part:IsA("Accessory") then
                if part:IsA("Accessory") and part.Handle then
                    part.Handle.Transparency = state and 1 or 0
                end
                part.Transparency = state and 1 or 0
            end
            -- Decals on parts (e.g. face)
            for _, decal in pairs(part:GetChildren()) do
                if decal:IsA("Decal") then
                    decal.Transparency = state and 1 or 0
                end
            end
        elseif part:IsA("Accessory") and part.Handle then
            -- In case hair is accessory outside BasePart loop
            part.Handle.Transparency = state and 1 or 0
        end
    end
end


local invisibilityEnabled = false
RightGroupBox:AddToggle("InvisibilityToggle", {
    Text = "Invisibility",
    Default = false,
    Tooltip = "Toggle player invisibility",
    Callback = function(state)
        invisibilityEnabled = state
        setCharacterVisibility(state)
    end,
})

-- Update invisibility on character respawn
localPlayer.CharacterAdded:Connect(function(newChar)
    character = newChar
    task.wait(1) -- wait for character parts to load
    if invisibilityEnabled then
        setCharacterVisibility(true)
    end
end)

-- Low Graphics Mode toggle
RightGroupBox:AddToggle("LowGraphicsToggle", {
    Text = "Low Graphics Mode",
    Default = false,
    Tooltip = "Reduces graphics quality for better performance",
    Callback = function(state)
        if state then
            -- Simple approach: disable shadows, reduce quality
            settings().Rendering.QualityLevel = 1 -- lowest
            for _, light in pairs(workspace:GetDescendants()) do
                if light:IsA("ShadowMapEffect") or light:IsA("SpotLight") or light:IsA("PointLight") or light:IsA("SurfaceLight") then
                    light.Enabled = false
                end
            end
        else
            settings().Rendering.QualityLevel = 14 -- Roblox default max quality
            for _, light in pairs(workspace:GetDescendants()) do
                if light:IsA("ShadowMapEffect") or light:IsA("SpotLight") or light:IsA("PointLight") or light:IsA("SurfaceLight") then
                    light.Enabled = true
                end
            end
        end
    end,
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--== ✅ Aimbot Settings UI (under Groupbox) ==--

-- ✅ Correctly attach the keybind to the toggle
local AimbotToggle = Groupbox:AddToggle("AimbotEnabled", {
    Text = "Enable Aimbot",
    Default = false,
})

local AimbotKeybind = AimbotToggle:AddKeyPicker("AimbotKeybind", {
    Text = "Aimbot Key",
    Default = "MouseButton2",
    Mode = "Hold",
    SyncToggleState = true,
    Callback = function(val)
        AimbotToggle:SetValue(val)
    end,
})


-- Silent aim toggle
Groupbox:AddToggle("SilentAim", {
    Text = "Enable Silent Aim",
    Default = false,
    Tooltip = "Redirects shots to target silently"
})

-- FOV toggle + color
local FOVToggle = Groupbox:AddToggle("ShowFOV", {
    Text = "Show FOV Circle",
    Default = true,
    Tooltip = "Draws a circle around aim radius"
})
FOVToggle:AddColorPicker("FOVColor", {
    Title = "FOV Circle Color",
    Default = Color3.fromRGB(255, 0, 0)
})

-- Other toggles
Groupbox:AddToggle("TeamCheck", {
    Text = "Ignore Teammates",
    Default = true
})

Groupbox:AddToggle("VisibilityCheck", {
    Text = "Visibility Check",
    Default = true
})

Groupbox:AddToggle("Prediction", {
    Text = "Enable Prediction",
    Default = true
})

-- Dropdowns
Groupbox:AddDropdown("TargetBone", {
    Text = "Target Bone",
    Values = { "Head", "Torso", "HumanoidRootPart" },
    Default = 1
})

Groupbox:AddDropdown("AimMode", {
    Text = "Target Selection",
    Values = { "ClosestToCrosshair", "ClosestDistance" },
    Default = 1
})

-- Sliders
Groupbox:AddSlider("FOV", {
    Text = "Aimbot FOV",
    Min = 20,
    Max = 300,
    Default = 90
})

Groupbox:AddSlider("Smoothness", {
    Text = "Aimbot Smoothness",
    Min = 1,
    Max = 20,
    Default = 6,
    Rounding = 1
})

Groupbox:AddSlider("MaxDistance", {
    Text = "Max Target Distance",
    Min = 100,
    Max = 10000,
    Default = 1000,
    Rounding = 0
})

--== ✅ FOV Circle Drawing ==--

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 100
fovCircle.Radius = 90
fovCircle.Filled = false
fovCircle.ZIndex = 2
fovCircle.Transparency = 1
fovCircle.Visible = false
fovCircle.Color = Color3.fromRGB(255, 0, 0)

RunService.RenderStepped:Connect(function()
    fovCircle.Visible = Options.AimbotEnabled.Value and Options.ShowFOV.Value
    fovCircle.Color = Options.FOVColor.Value
    fovCircle.Radius = Options.FOV.Value
    fovCircle.Position = UserInputService:GetMouseLocation()
end)

--== ✅ Target Finder ==--

local function getCharacter(player)
    local char = player.Character
    if not char or not char:FindFirstChild("Humanoid") or char:FindFirstChild("Humanoid").Health <= 0 then
        return nil
    end
    return char
end

local function isVisible(part)
    if not part then return false end
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin).Unit * 10000

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = { LocalPlayer.Character }

    local ray = Workspace:Raycast(origin, direction, rayParams)
    return ray and ray.Instance and ray.Instance:IsDescendantOf(part.Parent)
end

local function getTarget()
    local bestTarget = nil
    local bestValue = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local char = getCharacter(player)
            if char then
                local part = char:FindFirstChild(Options.TargetBone.Value)
                if not part then continue end

                if Options.TeamCheck.Value and player.Team == LocalPlayer.Team then continue end
                if Options.VisibilityCheck.Value and not isVisible(part) then continue end

                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if not onScreen then continue end

                local mouse = UserInputService:GetMouseLocation()
                local distToMouse = (Vector2.new(screenPos.X, screenPos.Y) - mouse).Magnitude
                local worldDist = (Camera.CFrame.Position - part.Position).Magnitude

                if worldDist > Options.MaxDistance.Value then continue end
                if distToMouse > Options.FOV.Value then continue end

                local priority = Options.AimMode.Value == "ClosestDistance" and worldDist or distToMouse

                if priority < bestValue then
                    bestValue = priority
                    bestTarget = part
                end
            end
        end
    end

    return bestTarget
end

--== ✅ Aimbot Aim Function (Legit) ==--

local function aimAt(part)
    local origin = Camera.CFrame.Position
    local pos = part.Position

    if Options.Prediction.Value and part.Parent:FindFirstChild("HumanoidRootPart") then
        local vel = part.Parent.HumanoidRootPart.Velocity
        local distance = (origin - pos).Magnitude
        pos = pos + vel * (distance / 1000)
    end

    local dir = (pos - origin).Unit
    local targetCF = CFrame.new(origin, origin + dir)
    Camera.CFrame = Camera.CFrame:Lerp(targetCF, 1 / Options.Smoothness.Value)
end

--== ✅ Silent Aim Hook ==--

getgenv().SilentTarget = nil

local __namecall
__namecall = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = { ... }

    if method == "FindPartOnRayWithIgnoreList" and Options.SilentAim.Value and SilentTarget then
        local origin = Camera.CFrame.Position
        local direction = (SilentTarget.Position - origin).Unit * 1000
        args[1] = Ray.new(origin, direction)
        return __namecall(self, unpack(args))
    end

    return __namecall(self, ...)
end)

--== ✅ Runtime Loop ==--

RunService.RenderStepped:Connect(function()
    if not Options.AimbotEnabled.Value then
        SilentTarget = nil
        return
    end

    local target = getTarget()
    SilentTarget = target

    if target and Options.SilentAim.Value then
        return -- silent aim handles it
    end

    if target and Options.AimbotKey.Hold and not Options.SilentAim.Value then
        aimAt(target)
    end
end)


--  Game Detection
local GameList = {
    [155615604] = {Name = "Prison Life", Detected = false},

}

local currentPlaceId = game.PlaceId
local gameInfo = GameList[currentPlaceId]

if not gameInfo then
    game:GetService("Players").LocalPlayer:Kick("❌ Unknown Game. Access Denied.")
    return
end

local detectionStatus = gameInfo.Detected and "✅ Detected" or "❌ Undetected"

local gameNameLabel = Status:AddLabel("Game Name: " .. gameInfo.Name)
local detectionStatusLabel = Status:AddLabel("Detection Status: " .. detectionStatus)

Status:AddToggle("ShowMinimalOverlay", {
    Text = "Show INFO",
    Default = false,
    Tooltip = "Toggle minimal performance overlay",
    Callback = function(value)
        if value then
            StartMinimalOverlay()
        else
            StopMinimalOverlay()
        end
    end
})

local UserInputService = game:GetService("UserInputService")

local overlayGui = Instance.new("ScreenGui")
overlayGui.Name = "PingFPSOverlay"
overlayGui.IgnoreGuiInset = true
overlayGui.ResetOnSpawn = false
overlayGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
overlayGui.Parent = game:FindFirstChildOfClass("CoreGui")

local fpsPingLabel = Instance.new("TextLabel")
fpsPingLabel.Name = "FPSPingDisplay"
fpsPingLabel.Position = UDim2.new(0.5, -75, 0, 5) -- Center top
fpsPingLabel.Size = UDim2.new(0, 150, 0, 25)
fpsPingLabel.BackgroundTransparency = 0.3
fpsPingLabel.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
fpsPingLabel.BorderSizePixel = 0
fpsPingLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
fpsPingLabel.Font = Enum.Font.SourceSansBold
fpsPingLabel.TextSize = 14
fpsPingLabel.TextStrokeTransparency = 0.8
fpsPingLabel.TextXAlignment = Enum.TextXAlignment.Center
fpsPingLabel.Visible = false
fpsPingLabel.Parent = overlayGui

-- Drag functionality
local dragging = false
local dragInput, dragStart, startPos

local function updatePosition(input)
    local delta = input.Position - dragStart
    fpsPingLabel.Position = UDim2.new(
        startPos.X.Scale,
        startPos.X.Offset + delta.X,
        startPos.Y.Scale,
        startPos.Y.Offset + delta.Y
    )
end

fpsPingLabel.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = fpsPingLabel.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

fpsPingLabel.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        updatePosition(input)
    end
end)

-- Color helper: linear interpolation between green and red
local function lerpColor(color1, color2, t)
    return Color3.new(
        color1.R + (color2.R - color1.R) * t,
        color1.G + (color2.G - color1.G) * t,
        color1.B + (color2.B - color1.B) * t
    )
end

local runningOverlay = false

function StartMinimalOverlay()
    runningOverlay = true
    fpsPingLabel.Visible = true

    task.spawn(function()
        local lastTime = tick()
        local frameCount = 0
        local fps = 0

        while runningOverlay and not Library.Unloaded do
            frameCount = frameCount + 1
            local currentTime = tick()
            local delta = currentTime - lastTime

            if delta >= 1 then  -- update FPS every second
                fps = frameCount / delta
                frameCount = 0
                lastTime = currentTime
            end

            local ping = 999
            local perfStats = Stats:FindFirstChild("PerformanceStats")
            if perfStats and perfStats:FindFirstChild("Ping") then
                ping = perfStats.Ping:GetValue()
            end

            -- Color coding
            local fpsT = math.clamp((fps - 15) / (60 - 15), 0, 1)
            local fpsColor = lerpColor(Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 255, 0), fpsT)

            local pingT = 1 - math.clamp((ping - 50) / (250 - 50), 0, 1)
            local pingColor = lerpColor(Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 255, 0), pingT)

            local overallT = math.min(fpsT, pingT)
            local overallColor = lerpColor(Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 255, 0), overallT)

            fpsPingLabel.Text = string.format("FPS: %d | Ping: %dms", math.floor(fps), ping)
            fpsPingLabel.TextColor3 = overallColor

            task.wait(0.1) -- update 10 times a second for smoother updates
        end
    end)
end


function StopMinimalOverlay()
    runningOverlay = false
    fpsPingLabel.Visible = false
end

Status:AddButton({
    Text = "Join Our Discord",
    Func = function()

        local discordLink = "https://discord.gg/dfgegzCtxH"
        
        setclipboard(discordLink)
        
        Library:Notify("Discord Link Copied!", "The invite link has been copied to your clipboard. Open your browser and paste it to join!")
    end,
    Tooltip = "Click to copy Discord invite link",
})


local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu", "wrench")

MenuGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "Open Keybind Menu",
    Callback = function(value)
        Library.KeybindFrame.Visible = value
    end,
})

MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Custom Cursor",
    Default = true,
    Callback = function(Value)
        Library.ShowCustomCursor = Value
    end,
})

MenuGroup:AddDropdown("NotificationSide", {
    Values = { "Left", "Right" },
    Default = "Right",
    Text = "Notification Side",
    Callback = function(Value)
        Library:SetNotifySide(Value)
    end,
})

MenuGroup:AddDropdown("DPIDropdown", {
    Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
    Default = "100%",
    Text = "DPI Scale",
    Callback = function(Value)
        Value = Value:gsub("%%", "")
        local DPI = tonumber(Value)
        Library:SetDPIScale(DPI)
    end,
})

MenuGroup:AddDivider()

MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", {
    Default = "RightShift",
    NoUI = true,
    Text = "Menu keybind"
})

MenuGroup:AddButton("Unload", function()
    Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("MyScriptHub")
SaveManager:SetFolder("MyScriptHub/specific-game")
SaveManager:SetSubFolder("specific-place")

SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])

SaveManager:LoadAutoloadConfig()
