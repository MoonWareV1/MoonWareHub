local repo = "https://raw.githubusercontent.com/MoonWareV1/MoonWareHub/main/"

local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Stats = game:GetService("Stats")
local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

local Window = Library:CreateWindow({
    Title = "MoonWare",
    Footer = "Version: Roblox",
    Icon = 118885599201447,
    NotifySide = "Left",
    ShowCustomCursor = true,
})

local Tabs = {
    Info = Window:AddTab("Information", "info"),
    Main = Window:AddTab("Main", "user"),
    Weapons = Window:AddTab("Weapon", "shield-user"),
    Misc = Window:AddTab("MISC", "server"),
    ["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox("Movement", "person-standing")
local RightGroupBox = Tabs.Main:AddRightGroupbox("MISC", "plus")
local Groupbox = Tabs.Weapons:AddLeftGroupbox("AimBot", "crosshair")
local LeftGroupBox2 = Tabs.Weapons:AddLeftGroupbox("Visuals", "view")
local Gun = Tabs.Weapons:AddRightGroupbox("Weapons", "view")
local Misc = Tabs.Misc:AddLeftGroupbox("More", "server")
local Status = Tabs.Info:AddLeftGroupbox("Status", "chart-bar")
local Update = Tabs.Info:AddRightGroupbox("Update Logs", "arrow-up-from-line")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Workspace = game:GetService("Workspace")

--// Forced God Mode (Advanced)
RightGroupBox:AddToggle("ForcedGodMode", {
    Text = "Forced God Mode",
    Default = false,
    Tooltip = "Keeps your health at max even after death/reset",
    Callback = function(Value)
        local lp = game.Players.LocalPlayer
        if Value then
            -- Connection to force health back up
            _G.ForceGodMode = true
            task.spawn(function()
                while _G.ForceGodMode and task.wait(0.1) do
                    if lp.Character and lp.Character:FindFirstChild("Humanoid") then
                        local hum = lp.Character.Humanoid
                        if hum.Health < hum.MaxHealth then
                            hum.Health = hum.MaxHealth
                        end
                    end
                end
            end)
        else
            _G.ForceGodMode = false
        end
    end,
})

-- Kill Aura Distance Slider
RightGroupBox:AddSlider("AuraRange", {
    Text = "Aura Range",
    Default = 15,
    Min = 5,
    Max = 50,
    Rounding = 0,
    Tooltip = "How far the aura reaches (in studs)"
})

-- Team Check Toggle
RightGroupBox:AddToggle("AuraTeamCheck", {
    Text = "Ignore Teammates",
    Default = true,
    Tooltip = "Won't attack players on your own team"
})

-- Advanced Kill Aura Toggle
RightGroupBox:AddToggle("Kill Aura", {
    Text = "Advanced Kill Aura",
    Default = false,
    Tooltip = "Automatically melee nearby enemies",
    Callback = function(Value)
        if Value then
            _G.AdvancedAura = true
            task.spawn(function()
                local lp = game.Players.LocalPlayer
                local meleeEvent = game:GetService("ReplicatedStorage").meleeEvent

                while _G.AdvancedAura and task.wait(0.05) do -- faster tick
                    local myHRP = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
                    if myHRP then
                        for _, e in pairs(game.Players:GetPlayers()) do
                            if e ~= lp and e.Character and e.Character:FindFirstChild("HumanoidRootPart") then
                                -- team check option
                                if Options.AuraTeamCheck.Value and e.Team == lp.Team then
                                    continue
                                end
                                local dist = (myHRP.Position - e.Character.HumanoidRootPart.Position).Magnitude
                                if dist <= Options.AuraRange.Value then
                                    meleeEvent:FireServer(e)
                                end
                            end
                        end
                    end
                end
            end)
        else
            _G.AdvancedAura = false
        end
    end,
})

-- Function to detect all guns in the map
local function getAvailableGuns()
    local guns = {}
    local giverFolder = workspace:FindFirstChild("Prison_ITEMS") and workspace.Prison_ITEMS:FindFirstChild("giver")
    if giverFolder then
        for _, gun in pairs(giverFolder:GetChildren()) do
            if gun:IsA("Model") and gun:FindFirstChild("ITEMPICKUP") then
                table.insert(guns, gun.Name)
            end
        end
    end
    return guns
end

-- Function to teleport to the gun, click it, and return
local function pickupGun(gunName)
    local giverFolder = workspace:FindFirstChild("Prison_ITEMS") and workspace.Prison_ITEMS:FindFirstChild("giver")
    if not giverFolder then
        warn("No gun spawners found!")
        return
    end

    local gun = giverFolder:FindFirstChild(gunName)
    if not gun or not gun:FindFirstChild("ITEMPICKUP") then
        warn("Gun not found: "..gunName)
        return
    end

    local Character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    local gunPart = gun.ITEMPICKUP
    local originalPos = HumanoidRootPart.Position

    -- Teleport to gun
    HumanoidRootPart.CFrame = CFrame.new(gunPart.Position + Vector3.new(0,3,0))

    -- Fire remote to simulate click
    local args = {gunPart}
    workspace.Remote.ItemHandler:InvokeServer(unpack(args))

    task.wait(0.2) -- short wait to avoid issues

    -- Teleport back
    HumanoidRootPart.CFrame = CFrame.new(originalPos)
end

-- Add dropdown and buttons to your existing Gun groupbox
local GunDropdown = Gun:AddDropdown("Select Gun", getAvailableGuns(), function(selectedGun)
    pickupGun(selectedGun)
end)

local RefreshButton = Gun:AddButton("Refresh Guns", function()
    GunDropdown:UpdateOptions(getAvailableGuns())
end)

local PickupButton = Gun:AddButton("Pickup Selected Gun", function()
    local selectedGun = GunDropdown.Value
    if selectedGun then
        pickupGun(selectedGun)
    else
        warn("No gun selected!")
    end
end)


-- WalkSpeed Slider
LeftGroupBox:AddSlider("WalkSpeedSlider", {
    Text = "WalkSpeed",
    Default = 16,  -- Roblox default walkspeed
    Min = 8,
    Max = 200,
    Rounding = 1,
    Callback = function(value)
        if Humanoid then
            Humanoid.WalkSpeed = value
        end
        print("WalkSpeed set to:", value)
    end,
    Tooltip = "Walking speed",
})

Options.WalkSpeedSlider:SetValue(16) -- default value

-- WalkSpeed Reset Button
LeftGroupBox:AddButton({
    Text = "Reset WalkSpeed",
    Func = function()
        if Humanoid then
            Humanoid.WalkSpeed = 16
        end
        Options.WalkSpeedSlider:SetValue(16)
        print("WalkSpeed reset to default (16)")
    end,
    Tooltip = "Reset WalkSpeed",
})

-- JumpPower Slider
LeftGroupBox:AddSlider("JumpPowerSlider", {
    Text = "Jump Power",
    Default = 50, -- Roblox default jump power
    Min = 20,
    Max = 200,
    Rounding = 1,
    Callback = function(value)
        if Humanoid then
            Humanoid.JumpPower = value
        end
        print("JumpPower set to:", value)
    end,
    Tooltip = "Jump power",
})

Options.JumpPowerSlider:SetValue(50) -- default value

-- JumpPower Reset Button
LeftGroupBox:AddButton({
    Text = "Reset JumpPower",
    Func = function()
        if Humanoid then
            Humanoid.JumpPower = 50
        end
        Options.JumpPowerSlider:SetValue(50)
        print("JumpPower reset to default (50)")
    end,
    Tooltip = "Reset JumpPower",
})

LeftGroupBox:AddDivider()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Variables
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

local flying = false
local flySpeed = 50  -- default speed, will be controlled by slider

local bodyVelocity
local bodyGyro

-- Update character references on respawn
local function setupCharacterRefs(newCharacter)
    character = newCharacter
    hrp = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
end

-- Smooth damping helper (not currently used but keep if you want to add smoothness)
local function damp(current, target, speed, dt)
    return current + (target - current) * math.clamp(speed * dt, 0, 1)
end

-- Fly toggle logic
local function toggleFly(state)
    flying = state

    if flying then
        if bodyVelocity then bodyVelocity:Destroy() end
        if bodyGyro then bodyGyro:Destroy() end

        bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
        bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        bodyVelocity.Parent = hrp

        bodyGyro = Instance.new("BodyGyro")
        bodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
        bodyGyro.P = 2000
        bodyGyro.D = 100
        bodyGyro.CFrame = workspace.CurrentCamera.CFrame
        bodyGyro.Parent = hrp

        humanoid.PlatformStand = true

        RunService:BindToRenderStep("FlyMovement", Enum.RenderPriority.Character.Value, function(dt)
            if not flying then return end

            local moveDir = Vector3.new(0, 0, 0)
            local camCF = workspace.CurrentCamera.CFrame

            if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveDir += camCF.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveDir -= camCF.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveDir -= camCF.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveDir += camCF.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveDir += Vector3.new(0,1,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveDir -= Vector3.new(0,1,0) end

            -- Normalize movement direction
            if moveDir.Magnitude > 0 then
                moveDir = moveDir.Unit
                bodyVelocity.Velocity = moveDir * flySpeed
            else
                bodyVelocity.Velocity = Vector3.new(0,0,0)
            end

            -- Camera follow rotation
            bodyGyro.CFrame = camCF
        end)

    else
        if bodyVelocity then
            bodyVelocity:Destroy()
            bodyVelocity = nil
        end

        if bodyGyro then
            bodyGyro:Destroy()
            bodyGyro = nil
        end

        humanoid.PlatformStand = false
        RunService:UnbindFromRenderStep("FlyMovement")
    end
end

-- Add slider for controlling fly speed
local FlySpeedSlider = LeftGroupBox:AddSlider("FlySpeed", {
    Text = "Fly Speed",
    Default = flySpeed,
    Min = 10,
    Max = 200,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        flySpeed = value
    end,
})

-- Fly toggle UI element
local FlyToggle = LeftGroupBox:AddToggle("FlyEnabled", {
    Text = "Enable Flying",
    Default = false,
    Tooltip = "Flight mode",
    Callback = function(state)
        toggleFly(state)
    end,
})

-- Fly keybind toggle
local FlyKey = FlyToggle:AddKeyPicker("FlyKeybind", {
    Text = "Fly Toggle Key",
    Default = "",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function(value)
        FlyToggle:SetValue(value)
    end,
    ChangedCallback = function(newKey)
        print("Fly key changed to:", newKey)
    end,
})

LeftGroupBox:AddDivider()

-- Re-bind character references and maintain flying on respawn
localPlayer.CharacterAdded:Connect(function(newCharacter)
    setupCharacterRefs(newCharacter)

    if flying then
        -- Re-enable fly on respawn
        toggleFly(false)  -- turn off first just in case
        task.wait(0.1)
        toggleFly(true)
    end
end)

-- Initial setup call in case character already loaded
setupCharacterRefs(character)

-- Optional: support "Hold" mode for keybind (your existing loop)
task.spawn(function()
    while true do
        task.wait(0.1)

        local state = Options.FlyKeybind:GetState()
        local mode = Options.FlyKeybind.Value[2]

        if mode == "Hold" then
            if state and not flying then
                toggleFly(true)
                Options.FlyEnabled:SetValue(true)
            elseif not state and flying then
                toggleFly(false)
                Options.FlyEnabled:SetValue(false)
            end
        end
    end
end)


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local noclipEnabled = false
local noclipConnection = nil
local noclipDebounce = false

local function cleanupNoclip(character)
    if not character then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")

    if hrp then
        -- Lift the character slightly to avoid clipping into the floor
        hrp.CFrame = hrp.CFrame + Vector3.new(0, 3, 0)
    end

    -- Gradually restore collisions on parts
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
            task.wait(0.01)  -- tiny delay to smooth physics update
        end
    end
end

local function toggleNoclip(state)
    if noclipDebounce then return end
    noclipDebounce = true

    noclipEnabled = state
    if noclipEnabled then
        print("Noclip Enabled")
        noclipConnection = RunService.Stepped:Connect(function()
            local character = LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        print("Noclip Disabled")
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end

        cleanupNoclip(LocalPlayer.Character)
    end

    task.delay(0.2, function()
        noclipDebounce = false
    end)
end

LocalPlayer.CharacterAdded:Connect(function(character)
    if not noclipEnabled then
        -- Just in case, reset collisions when character respawns
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end)

local NoclipToggle = LeftGroupBox:AddToggle("NoclipEnabled", {
    Text = "Enable Noclip",
    Default = false,
    Tooltip = "Walk through walls",
    Callback = function(state)
        toggleNoclip(state)
    end
})

local NoclipKeybind = NoclipToggle:AddKeyPicker("NoclipKeybind", {
    Text = "Noclip Toggle Key",
    Default = "",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function(value)
        NoclipToggle:SetValue(value)
    end,
    ChangedCallback = function(newKey)
        print("Noclip key changed to:", newKey)
    end
})


Library:OnUnload(function()
    if noclipConnection then
        noclipConnection:Disconnect()
    end
    print("Unloaded!")
end)

Library:OnUnload(function()
    print("Unloaded!")
end)

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Player references
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- INF JUMP
local infJumpEnabled = false

local function onJumpRequest()
    if infJumpEnabled then
        localPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end

-- TELEPORT TO MOUSE
local teleportEnabled = false
local teleportKey = Enum.KeyCode.T -- default key for teleport toggle (you can change or add keypicker later)

local function teleportToMouse()
    local mouse = localPlayer:GetMouse()
    local targetPos = mouse.Hit.Position

    -- Raycast downwards to find a safe ground position to teleport to
    local rayOrigin = targetPos + Vector3.new(0, 50, 0)
    local rayDirection = Vector3.new(0, -100, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {localPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local rayResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    if rayResult then
        local safePos = rayResult.Position + Vector3.new(0, 3, 0) -- teleport a bit above ground
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(safePos)
        end
    end
end

-- UI toggles for Infinite Jump
local InfJumpToggle = LeftGroupBox:AddToggle("InfJumpEnabled", {
    Text = "Enable Infinite Jump",
    Default = false,
    Tooltip = "inf jumping",
    Callback = function(state)
        infJumpEnabled = state
    end
})

-- UI toggles for Teleport to Mouse
local TeleportToggle = LeftGroupBox:AddToggle("TeleportEnabled", {
    Text = "Enable Teleport to Mouse",
    Default = false,
    Tooltip = "teleport to mouse",
    Callback = function(state)
        teleportEnabled = state
    end
})

local TeleportKeybind = TeleportToggle:AddKeyPicker("TeleportKeybind", {
    Text = "Teleport Toggle Key",
    Default = "",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function(value)
        -- nothing extra needed here
    end,
    ChangedCallback = function(newKey)
        teleportKey = Enum.KeyCode[newKey] or Enum.KeyCode.T
    end
})

-- Connections
UserInputService.JumpRequest:Connect(function()
    if infJumpEnabled then
        onJumpRequest()
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if teleportEnabled and input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == teleportKey then
            teleportToMouse()
        end
    end
end)

-- Character reset handling (optional but good practice)
localPlayer.CharacterAdded:Connect(function(char)
    character = char
    humanoid = character:WaitForChild("Humanoid")
    hrp = character:WaitForChild("HumanoidRootPart")
end)

-- Anti-AFK
local VirtualUser = game:GetService("VirtualUser")

RightGroupBox:AddToggle("AntiAFK", {
    Text = "Anti AFK",
    Default = false,
    Tooltip = "Prevents you from getting kicked for being idle",
    Callback = function(state)
        if state then
            local connection
            connection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
            Options.AntiAFK.Connection = connection
        else
            if Options.AntiAFK.Connection then
                Options.AntiAFK.Connection:Disconnect()
                Options.AntiAFK.Connection = nil
            end
        end
    end
})

-- Player Teleportation dropdown and button
local playerList = {}
local playerDropdown = RightGroupBox:AddDropdown("PlayerTeleportDropdown", {
    Values = {},
    Default = nil,
    Text = "Select Player to Teleport",
    Tooltip = "Choose a player to teleport to",
    Callback = function(value)
        -- value will be the player's name
    end,
})

RightGroupBox:AddButton({
    Text = "Teleport to Player",
    Tooltip = "Teleport to selected player",
    Func = function()
        local selectedPlayerName = Options.PlayerTeleportDropdown.Value
        if not selectedPlayerName then
            Library:Notify("No Player Selected", "Please select a player first.")
            return
        end

        local targetPlayer = Players:FindFirstChild(selectedPlayerName)
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = targetPlayer.Character.HumanoidRootPart
            if character and hrp then
                hrp = hrp or targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                character.HumanoidRootPart.CFrame = hrp.CFrame + Vector3.new(0, 3, 0)
                Library:Notify("Teleported!", "Teleported to player: " .. selectedPlayerName)
            end
        else
            Library:Notify("Player Not Found", "The selected player is not available for teleport.")
        end
    end,
})

-- Update player list without lag on join/leave and periodically
local function updatePlayerDropdown()
    local names = {}
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= localPlayer then
            table.insert(names, plr.Name)
        end
    end
    table.sort(names)
    playerDropdown:SetValues(names)
end

Players.PlayerAdded:Connect(function()
    task.wait(1) -- small delay to let player fully load
    updatePlayerDropdown()
end)

Players.PlayerRemoving:Connect(function()
    task.wait(0.5)
    updatePlayerDropdown()
end)

-- Initial populate
updatePlayerDropdown()

--// Prison Life Map Teleportation
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Predefined map locations
local mapTeleportTable = {
    {Name = "Criminal Base", CFrame = CFrame.new(-943.8, 94.1, 2064.5)},
    {Name = "Yard", CFrame = CFrame.new(828.1, 97.9, 2462.4)},
    {Name = "Cafeteria", CFrame = CFrame.new(919.4, 99.9, 2447.2)},
    {Name = "Police Station", CFrame = CFrame.new(781.7, 99.9, 2292.4)},
    {Name = "Gate Entrance", CFrame = CFrame.new(791.3, 98.9, 2186.2)},
}

-- Build dropdown values
local locationNames = {}
for _, loc in ipairs(mapTeleportTable) do
    table.insert(locationNames, loc.Name)
end

-- Dropdown for selecting location
local locationDropdown = RightGroupBox:AddDropdown("MapTeleportDropdown", {
    Values = locationNames,
    Default = locationNames[1],
    Text = "Select Location",
    Tooltip = "Choose where to teleport on the map",
})

-- Button to teleport
RightGroupBox:AddButton({
    Text = "Teleport to Location",
    Tooltip = "Teleport to selected location on the map",
    Func = function()
        local selectedLocation = Options.MapTeleportDropdown.Value
        if not selectedLocation then
            Library:Notify("No Location Selected", "Please select a location first.")
            return
        end

        for _, loc in ipairs(mapTeleportTable) do
            if loc.Name == selectedLocation then
                if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    localPlayer.Character.HumanoidRootPart.CFrame = loc.CFrame + Vector3.new(0, 3, 0) -- small offset to prevent clipping
                    Library:Notify("Teleported!", "Moved to "..loc.Name)
                else
                    Library:Notify("Teleport Failed", "Character not found.")
                end
                return
            end
        end

        Library:Notify("Location Not Found", "The selected location was not found.")
    end,
})


local camModsEnabled = false
local camFOV = 70

-- Cam Mods toggle
RightGroupBox:AddToggle("CamModsToggle", {
    Text = "Cam Mods",
    Default = false,
    Tooltip = "Camera modifications",
    Callback = function(state)
        camModsEnabled = state
        if not camModsEnabled then
            -- Reset FOV to default 70 when disabled
            workspace.CurrentCamera.FieldOfView = 70
            Options.CamFOVSlider:SetDisabled(true)
        else
            -- Enable slider when cam mods enabled
            Options.CamFOVSlider:SetDisabled(false)
            workspace.CurrentCamera.FieldOfView = camFOV
        end
    end,
})

-- Cam FOV slider (70 to 150)
RightGroupBox:AddSlider("CamFOVSlider", {
    Text = "Camera FOV",
    Default = 70,
    Min = 70,
    Max = 150,
    Rounding = 0,
    Tooltip = "Adjust the camera field of view",
    Callback = function(value)
        camFOV = value
        if camModsEnabled then
            workspace.CurrentCamera.FieldOfView = camFOV
        end
    end,
    Disabled = true, -- disabled by default until toggle enabled
})


-- Invisibility toggle
local function setCharacterVisibility(state)
    if not character then return end
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.Transparency = state and 1 or 0
            -- Special case for hair/accessories: also disable them
            if part.Name:lower():find("hair") or part:IsA("Accessory") then
                if part:IsA("Accessory") and part.Handle then
                    part.Handle.Transparency = state and 1 or 0
                end
                part.Transparency = state and 1 or 0
            end
            -- Decals on parts (e.g. face)
            for _, decal in pairs(part:GetChildren()) do
                if decal:IsA("Decal") then
                    decal.Transparency = state and 1 or 0
                end
            end
        elseif part:IsA("Accessory") and part.Handle then
            -- In case hair is accessory outside BasePart loop
            part.Handle.Transparency = state and 1 or 0
        end
    end
end


local invisibilityEnabled = false
RightGroupBox:AddToggle("InvisibilityToggle", {
    Text = "Invisibility",
    Default = false,
    Tooltip = "Toggle player invisibility",
    Callback = function(state)
        invisibilityEnabled = state
        setCharacterVisibility(state)
    end,
})

-- Update invisibility on character respawn
localPlayer.CharacterAdded:Connect(function(newChar)
    character = newChar
    task.wait(1) -- wait for character parts to load
    if invisibilityEnabled then
        setCharacterVisibility(true)
    end
end)

-- Low Graphics Mode toggle
RightGroupBox:AddToggle("LowGraphicsToggle", {
    Text = "Low Graphics Mode",
    Default = false,
    Tooltip = "Reduces graphics quality for better performance",
    Callback = function(state)
        if state then
            -- Simple approach: disable shadows, reduce quality
            settings().Rendering.QualityLevel = 1 -- lowest
            for _, light in pairs(workspace:GetDescendants()) do
                if light:IsA("ShadowMapEffect") or light:IsA("SpotLight") or light:IsA("PointLight") or light:IsA("SurfaceLight") then
                    light.Enabled = false
                end
            end
        else
            settings().Rendering.QualityLevel = 14 -- Roblox default max quality
            for _, light in pairs(workspace:GetDescendants()) do
                if light:IsA("ShadowMapEffect") or light:IsA("SpotLight") or light:IsA("PointLight") or light:IsA("SurfaceLight") then
                    light.Enabled = true
                end
            end
        end
    end,
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Your UI (unchanged exactly as you gave me)

-- Master toggle for aimbot
local AimbotToggle = Groupbox:AddToggle("AimbotEnabled", {
    Text = "Enable Aimbot",
    Default = false,
    Tooltip = "First Persion for this.",
})

-- Keybind for aimbot
local AimbotKeybind = AimbotToggle:AddKeyPicker("AimbotKeybind", {
    Text = "Aimbot Key",
    Default = "F",
    Mode = "Hold",
    SyncToggleState = false,
})

-- FOV Slider
Groupbox:AddSlider("AimbotFOV", {
    Text = "Aimbot FOV",
    Default = 180,
    Min = 10,
    Max = 720,
    Rounding = 0,
    Tooltip = "The field of view radius for the aimbot"
})

-- Smoothness Slider
Groupbox:AddSlider("AimbotSmoothness", {
    Text = "Aimbot Smoothness",
    Default = 10,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Tooltip = "Higher = slower aim, lower = faster"
})

-- Target Bone Dropdown
Groupbox:AddDropdown("TargetBone", {
    Values = { "Head", "UpperTorso", "HumanoidRootPart" },
    Default = "Head",
    Text = "Target Bone",
    Tooltip = "Which part of the enemy to aim at"
})

-- FOV Circle Toggle
local ShowFOVToggle = Groupbox:AddToggle("ShowFOVCircle", {
    Text = "Show FOV Circle",
    Default = false,
    Tooltip = "Draw a circle on screen showing the aimbot field of view",
})

-- FOV Circle Color Picker
ShowFOVToggle:AddColorPicker("FOVColor", {
    Default = Color3.fromRGB(255, 0, 0),
    Title = "FOV Circle Color",
    Transparency = 0,
})

-- Ignore teammates toggle
Groupbox:AddToggle("IgnoreTeammates", {
    Text = "Ignore Teammates",
    Default = false,
    Tooltip = "Avoid targeting players on your own team"
})

-- Visibility check toggle
Groupbox:AddToggle("VisibilityCheck", {
    Text = "Visibility Check",
    Default = false,
    Tooltip = "Only aim at targets visible from your crosshair (line-of-sight check)"
})


-- == Logic Code Starts Here == --

-- Access toggles and options from UI
local Toggles = Library.Toggles
local Options = Library.Options

-- Drawing the FOV Circle
local FOV_Circle = Drawing.new("Circle")
FOV_Circle.Thickness = 1.5
FOV_Circle.NumSides = 100
FOV_Circle.Filled = false
FOV_Circle.Transparency = 1
FOV_Circle.ZIndex = 2
FOV_Circle.Color = Options.FOVColor.Value or Color3.new(1, 0, 0)
FOV_Circle.Visible = false

-- Update FOV circle position and visibility every frame
RunService.RenderStepped:Connect(function()
    if Toggles.ShowFOVCircle.Value then
        local mousePos = UserInputService:GetMouseLocation()
        local adjustedPos = Vector2.new(mousePos.X, mousePos.Y - 36) -- adjust for Roblox top bar
        FOV_Circle.Position = adjustedPos
        FOV_Circle.Radius = Options.AimbotFOV.Value or 180
        FOV_Circle.Color = Options.FOVColor.Value or Color3.new(1, 0, 0)
        FOV_Circle.Visible = true
    else
        FOV_Circle.Visible = false
    end
end)

-- Helper: Check if position is on screen and get screen coords
local function IsOnScreen(pos)
    local screenPoint, onScreen = Camera:WorldToViewportPoint(pos)
    return onScreen, Vector2.new(screenPoint.X, screenPoint.Y)
end

-- Get target part to aim at (head, torso, root, etc)
local function GetTargetPart(character)
    local bone = Options.TargetBone.Value or "Head"
    return character:FindFirstChild(bone)
end

-- Raycast visibility check
local function IsVisible(targetCharacter)
    if not Toggles.VisibilityCheck.Value then
        return true
    end

    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, targetCharacter}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    local origin = Camera.CFrame.Position
    local direction = (targetCharacter.HumanoidRootPart.Position - origin).Unit * 500
    local result = Workspace:Raycast(origin, direction, rayParams)
    
    return (not result) or result.Instance:IsDescendantOf(targetCharacter)
end

-- Get closest valid target inside FOV circle
local function GetClosestTarget()
    local maxDist = Options.AimbotFOV.Value or 180
    local selectedTarget = nil
    local shortestDistance = maxDist

    local mousePos = UserInputService:GetMouseLocation()
    local adjustedMousePos = Vector2.new(mousePos.X, mousePos.Y - 36)

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Toggles.IgnoreTeammates.Value and player.Team == LocalPlayer.Team then continue end

        local character = player.Character
        if not character then continue end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or humanoid.Health <= 0 or not rootPart then continue end

        if not IsVisible(character) then continue end

        local onScreen, screenPos = IsOnScreen(rootPart.Position)
        if not onScreen then continue end

        local distToMouse = (screenPos - adjustedMousePos).Magnitude
        if distToMouse < shortestDistance then
            shortestDistance = distToMouse
            selectedTarget = character
        end
    end

    return selectedTarget
end

-- Smoothly aim camera at position
local function AimAt(position, smoothness)
    local camCF = Camera.CFrame
    local direction = (position - camCF.Position).Unit
    local targetCF = CFrame.new(camCF.Position, camCF.Position + direction)
    Camera.CFrame = camCF:Lerp(targetCF, smoothness)
end

-- Main Aimbot logic
RunService.RenderStepped:Connect(function()
    if not Toggles.AimbotEnabled.Value then return end
    if not Options.AimbotKeybind:GetState() then return end
    if Toggles.SilentAimOnly.Value then return end -- don't move camera in silent aim only mode

    local targetChar = GetClosestTarget()
    if not targetChar then return end

    local targetPart = GetTargetPart(targetChar)
    if not targetPart then return end

    local smoothness = Options.AimbotSmoothness.Value or 10
    AimAt(targetPart.Position, 1 / math.clamp(smoothness, 1, 100))
end)

-- Silent Aim implementation
local CurrentSilentTarget = nil

local function GetSilentAimTarget()
    if not Toggles.EnableSilentAim.Value then return nil end

    local targetChar = GetClosestTarget()
    if not targetChar then return nil end

    local part = GetTargetPart(targetChar)
    if not part then return nil end

    CurrentSilentTarget = part
    return part.Position
end

local __namecall
__namecall = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if not checkcaller() then
        if method == "Raycast" and typeof(self) == "Instance" and self:IsA("Workspace") then
            local targetPos = GetSilentAimTarget()
            if targetPos then
                local origin = args[1]
                local newDirection = (targetPos - origin).Unit * (args[2].Magnitude or 1000)
                args[2] = newDirection
                return __namecall(self, unpack(args))
            end
        end
    end

    return __namecall(self, ...)
end)

-- Reset aimbot state on death (fix UI bug)
local function OnCharacterAdded(character)
    local humanoid = character:WaitForChild("Humanoid")
    humanoid.Died:Connect(function()
        CurrentSilentTarget = nil
        -- Add any UI reset logic here if necessary
    end)
end

LocalPlayer.CharacterAdded:Connect(OnCharacterAdded)
if LocalPlayer.Character then
    OnCharacterAdded(LocalPlayer.Character)
end

--// ESP Section
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Toggles / flags
local espEnabled   = false
local showBoxes    = false
local showTracers  = false
local showNames    = false
local showDistance = false
local showHealth   = false

-- Storage
local ESPObjects = {}

-- Create ESP drawings
local function createESP(player)
    if player == LocalPlayer or ESPObjects[player] then return end

    local objects = {
        Box      = Drawing.new("Square"),
        Tracer   = Drawing.new("Line"),
        Name     = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        Health   = Drawing.new("Text"),
    }

    -- Defaults
    objects.Box.Color = Color3.fromRGB(0, 255, 0)
    objects.Box.Thickness = 2
    objects.Box.Filled = false
    objects.Box.Transparency = 1
    objects.Box.Visible = false

    objects.Tracer.Color = Color3.fromRGB(255, 255, 0)
    objects.Tracer.Thickness = 1
    objects.Tracer.Transparency = 1
    objects.Tracer.Visible = false

    for _, text in ipairs({objects.Name, objects.Distance, objects.Health}) do
        text.Size = 12
        text.Center = true
        text.Outline = true
        text.Visible = false
    end

    objects.Name.Color = Color3.fromRGB(255, 255, 255)
    objects.Distance.Color = Color3.fromRGB(200, 200, 200)
    objects.Health.Color = Color3.fromRGB(255, 0, 0)

    ESPObjects[player] = objects
end

-- Remove ESP drawings
local function removeESP(player)
    local obj = ESPObjects[player]
    if obj then
        for _, drawing in pairs(obj) do
            drawing:Remove()
        end
        ESPObjects[player] = nil
    end
end

-- Update ESP every frame
RunService.RenderStepped:Connect(function()
    if not espEnabled then return end

    for player, drawings in pairs(ESPObjects) do
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")

        if hrp and humanoid and humanoid.Health > 0 then
            local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)

            if onScreen then
                -- Box size
                local size = Vector2.new(2, 3) * (Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0)).Y - pos.Y)
                drawings.Box.Size = size
                drawings.Box.Position = Vector2.new(pos.X - size.X / 2, pos.Y - size.Y / 2)
                drawings.Box.Visible = showBoxes

                -- Tracer
                drawings.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                drawings.Tracer.To = Vector2.new(pos.X, pos.Y)
                drawings.Tracer.Visible = showTracers

                -- Name
                drawings.Name.Text = player.Name
                drawings.Name.Position = Vector2.new(pos.X, pos.Y - size.Y / 2 - 15)
                drawings.Name.Visible = showNames

                -- Distance
                local dist = (Camera.CFrame.Position - hrp.Position).Magnitude
                drawings.Distance.Text = string.format("%.0f studs", dist)
                drawings.Distance.Position = Vector2.new(pos.X, pos.Y + size.Y / 2 + 2)
                drawings.Distance.Visible = showDistance

                -- Health
                drawings.Health.Text = "HP: " .. math.floor(humanoid.Health)
                drawings.Health.Position = Vector2.new(pos.X, pos.Y + size.Y / 2 + 15)
                drawings.Health.Visible = showHealth
            else
                for _, v in pairs(drawings) do v.Visible = false end
            end
        else
            for _, v in pairs(drawings) do v.Visible = false end
        end
    end
end)

-- Manage player ESP
task.spawn(function()
    while true do
        if espEnabled then
            for _, player in ipairs(Players:GetPlayers()) do
                createESP(player)
            end
            for player in pairs(ESPObjects) do
                if not Players:FindFirstChild(player.Name) then
                    removeESP(player)
                end
            end
        end
        task.wait(1)
    end
end)

-- UI Toggles
local ESPMasterToggle = LeftGroupBox2:AddToggle("ESPMaster", {
    Text = "ESP Master", Default = false, Tooltip = "Enable full ESP system",
    Callback = function(value) espEnabled = value end
})

local ESPBoxesToggle = LeftGroupBox2:AddToggle("ESPBoxes", {
    Text = "ESP Boxes", Default = false, Tooltip = "Draw boxes around players",
    Callback = function(value) showBoxes = value end
})

local ESPTracersToggle = LeftGroupBox2:AddToggle("ESPTracers", {
    Text = "ESP Tracers", Default = false, Tooltip = "Draw tracer lines to players",
    Callback = function(value) showTracers = value end
})

local ESPNamesToggle = LeftGroupBox2:AddToggle("ESPNames", {
    Text = "ESP Name Tags", Default = false, Tooltip = "Show player names",
    Callback = function(value) showNames = value end
})

local ESPDistanceToggle = LeftGroupBox2:AddToggle("ESPDistance", {
    Text = "ESP Distance", Default = false, Tooltip = "Show distance to player",
    Callback = function(value) showDistance = value end
})

local ESPHealthToggle = LeftGroupBox2:AddToggle("ESPHealth", {
    Text = "ESP Health", Default = false, Tooltip = "Show player HP",
    Callback = function(value) showHealth = value end
})

-- Color Pickers
local ESPBoxColorPicker = ESPBoxesToggle:AddColorPicker("ESPBoxColor", {
    Default = Color3.fromRGB(0, 255, 0), Title = "Box Color", Transparency = 0,
    Callback = function(color) for _, obj in pairs(ESPObjects) do obj.Box.Color = color end end
})

local ESPTracerColorPicker = ESPTracersToggle:AddColorPicker("ESPTracerColor", {
    Default = Color3.fromRGB(255, 255, 0), Title = "Tracer Color", Transparency = 0,
    Callback = function(color) for _, obj in pairs(ESPObjects) do obj.Tracer.Color = color end end
})

local ESPNameColorPicker = ESPNamesToggle:AddColorPicker("ESPNameColor", {
    Default = Color3.fromRGB(255, 255, 255), Title = "Name Color", Transparency = 0,
    Callback = function(color) for _, obj in pairs(ESPObjects) do obj.Name.Color = color end end
})

local ESPHealthColorPicker = ESPHealthToggle:AddColorPicker("ESPHealthColor", {
    Default = Color3.fromRGB(255, 0, 0), Title = "Health Color", Transparency = 0,
    Callback = function(color) for _, obj in pairs(ESPObjects) do obj.Health.Color = color end end
})

local ESPDistanceColorPicker = ESPDistanceToggle:AddColorPicker("ESPDistanceColor", {
    Default = Color3.fromRGB(200, 200, 200), Title = "Distance Color", Transparency = 0,
    Callback = function(color) for _, obj in pairs(ESPObjects) do obj.Distance.Color = color end end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Gun Mods Config
local gunMods = {
    InfiniteAmmo   = false,
    RapidFire      = false,
    NoRecoil       = false,
    FireRate       = 0.05,

    InstantReload  = false,
    NoSpread       = false,
    InfiniteRange  = false,
    DamageBoost    = false,
    DamageValue    = 100,
    ForceAuto      = false,

    MultiShot      = false,
    BulletCount    = 5,

    RandomSpread   = false,
    SpreadAmount   = 5,
}

--// Hook cache (so we don’t double-hook)
local hookedGuns = {}

local function patchInfiniteAmmo(v)
    if hookedGuns[v] then return end
    if typeof(v.Fire) == "function" then
        local old
        old = hookfunction(v.Fire, function(self, ...)
            if gunMods.InfiniteAmmo then
                self.CurrentAmmo = math.huge
                self.StoredAmmo = math.huge
            end
            return old(self, ...)
        end)
        hookedGuns[v] = true
    end
end

--// Patcher Function
local function patchGuns()
    for _, v in pairs(getgc(true)) do
        if type(v) == "table" and rawget(v, "MaxAmmo") and rawget(v, "CurrentAmmo") then

            -- Infinite Ammo (hooked into Fire)
            if gunMods.InfiniteAmmo then
                v.MaxAmmo = math.huge
                patchInfiniteAmmo(v)
            end

            -- Rapid Fire
            if gunMods.RapidFire then
                v.FireRate = gunMods.FireRate
            end

            -- No Recoil
            if gunMods.NoRecoil then
                v.Recoil = 0
                v.CameraShake = 0
            end

            -- Instant Reload
            if gunMods.InstantReload then
                v.ReloadTime = 0.01
            end

            -- No Spread
            if gunMods.NoSpread then
                v.BulletSpread = 0
            end

            -- Infinite Range
            if gunMods.InfiniteRange then
                v.Range = math.huge
            end

            -- Damage Boost
            if gunMods.DamageBoost then
                v.Damage = gunMods.DamageValue
            end

            -- Force Auto
            if gunMods.ForceAuto then
                v.Auto = true
            end

            -- Multi-Shot
            if gunMods.MultiShot then
                v.Bullets = gunMods.BulletCount
            end

            -- Random Spread (only with MultiShot)
            if gunMods.RandomSpread and gunMods.MultiShot then
                v.BulletSpread = gunMods.SpreadAmount
            end
        end
    end
end

--// Heartbeat Update
task.spawn(function()
    while task.wait(0.25) do
        pcall(patchGuns)
    end
end)

--// UI Setup
Gun:AddToggle("InfiniteAmmo", {
    Text = "Infinite Ammo",
    Default = false,
    Callback = function(v) gunMods.InfiniteAmmo = v end,
})

Gun:AddToggle("RapidFire", {
    Text = "Rapid Fire",
    Default = false,
    Callback = function(v) gunMods.RapidFire = v end,
})

Gun:AddSlider("FireRate", {
    Text = "Fire Rate",
    Default = 0.05,
    Min = 0.01,
    Max = 0.2,
    Rounding = 3,
    Callback = function(v) gunMods.FireRate = v end,
})

Gun:AddToggle("NoRecoil", {
    Text = "No Recoil",
    Default = false,
    Callback = function(v) gunMods.NoRecoil = v end,
})

Gun:AddToggle("InstantReload", {
    Text = "Instant Reload",
    Default = false,
    Callback = function(v) gunMods.InstantReload = v end,
})

Gun:AddToggle("NoSpread", {
    Text = "No Spread",
    Default = false,
    Callback = function(v) gunMods.NoSpread = v end,
})

Gun:AddToggle("InfiniteRange", {
    Text = "Infinite Range",
    Default = false,
    Callback = function(v) gunMods.InfiniteRange = v end,
})

Gun:AddToggle("DamageBoost", {
    Text = "Damage Boost",
    Default = false,
    Callback = function(v) gunMods.DamageBoost = v end,
})

Gun:AddSlider("DamageValue", {
    Text = "Damage",
    Default = 100,
    Min = 25,
    Max = 500,
    Rounding = 0,
    Callback = function(v) gunMods.DamageValue = v end,
})

Gun:AddToggle("ForceAuto", {
    Text = "Force Auto",
    Default = false,
    Callback = function(v) gunMods.ForceAuto = v end,
})

Gun:AddToggle("MultiShot", {
    Text = "Multi-Shot",
    Default = false,
    Callback = function(v) gunMods.MultiShot = v end,
})

Gun:AddSlider("BulletCount", {
    Text = "Bullet Count",
    Default = 5,
    Min = 2,
    Max = 50,
    Rounding = 0,
    Callback = function(v) gunMods.BulletCount = v end,
})

Gun:AddToggle("RandomSpread", {
    Text = "Random Spread",
    Default = false,
    Callback = function(v) gunMods.RandomSpread = v end,
})

Gun:AddSlider("SpreadAmount", {
    Text = "Spread Amount",
    Default = 5,
    Min = 0,
    Max = 50,
    Rounding = 0,
    Callback = function(v) gunMods.SpreadAmount = v end,
})

--// Server Hop
Misc:AddButton({
    Text = "Server Hop",
    Tooltip = "Join a random new server",
    Func = function()
        local Http = game:GetService("HttpService")
        local TP = game:GetService("TeleportService")
        local servers = {}
        local req = syn and syn.request or http and http.request or http_request or request
        local response = req({
            Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100", game.PlaceId),
            Method = "GET"
        })
        local data = Http:JSONDecode(response.Body)
        for _, v in pairs(data.data) do
            if v.playing < v.maxPlayers and v.id ~= game.JobId then
                table.insert(servers, v.id)
            end
        end
        if #servers > 0 then
            TP:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], game.Players.LocalPlayer)
        else
            Library:Notify("No servers found", "Could not find another server to hop to.")
        end
    end,
})

--// Rejoin
Misc:AddButton({
    Text = "Rejoin Server",
    Tooltip = "Rejoin the same server",
    Func = function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
    end,
})

--// Low Player Server
Misc:AddButton({
    Text = "Low Player Server",
    Tooltip = "Find a server with the fewest players",
    Func = function()
        local Http = game:GetService("HttpService")
        local TP = game:GetService("TeleportService")
        local req = syn and syn.request or http and http.request or http_request or request
        local response = req({
            Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100", game.PlaceId),
            Method = "GET"
        })
        local data = Http:JSONDecode(response.Body)
        local lowestServer = nil
        local lowestCount = math.huge
        for _, v in pairs(data.data) do
            if v.playing < lowestCount and v.id ~= game.JobId then
                lowestCount = v.playing
                lowestServer = v.id
            end
        end
        if lowestServer then
            TP:TeleportToPlaceInstance(game.PlaceId, lowestServer, game.Players.LocalPlayer)
        else
            Library:Notify("No servers found", "Could not find a low player server.")
        end
    end,
})

--// Reset Character
Misc:AddButton({
    Text = "Reset Character",
    Tooltip = "Respawn without using Roblox menu",
    Func = function()
        local lp = game.Players.LocalPlayer
        lp.Character:BreakJoints()
    end,
})

--  Game Detection
local GameList = {
    [155615604] = {Name = "Prison Life", Detected = false},

}

local currentPlaceId = game.PlaceId
local gameInfo = GameList[currentPlaceId]

if not gameInfo then
    game:GetService("Players").LocalPlayer:Kick("❌ Unknown Game. Access Denied.")
    return
end

local detectionStatus = gameInfo.Detected and "✅ Detected" or "❌ Undetected"

local gameNameLabel = Status:AddLabel("Game Name: " .. gameInfo.Name)
local detectionStatusLabel = Status:AddLabel("Detection Status: " .. detectionStatus)


Status:AddButton({
    Text = "Join Our Discord",
    Func = function()

        local discordLink = "https://discord.gg/dfgegzCtxH"
        
        setclipboard(discordLink)
        
        Library:Notify("Discord Link Copied!", "The invite link has been copied to your clipboard. Open your browser and paste it to join!")
    end,
    Tooltip = "Click to copy Discord invite link",
})

local Label = Update:AddLabel("UPDATE LOGS")
local WrappedLabel = Update:AddLabel({
    Text = "Added Full Aimbot system.",
    DoesWrap = false
})

-- Sets the watermark visibility
Library:SetWatermarkVisibility(true)

-- Example of dynamically-updating watermark with common traits (fps and ping)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;

    Library:SetWatermark(('MoonWare🌑 | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ));
end);

local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu", "wrench")

MenuGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "Open Keybind Menu",
    Callback = function(value)
        Library.KeybindFrame.Visible = value
    end,
})

MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Custom Cursor",
    Default = true,
    Callback = function(Value)
        Library.ShowCustomCursor = Value
    end,
})

MenuGroup:AddDropdown("NotificationSide", {
    Values = { "Left", "Right" },
    Default = "Left",
    Text = "Notification Side",
    Callback = function(Value)
        Library:SetNotifySide(Value)
    end,
})

MenuGroup:AddDropdown("DPIDropdown", {
    Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
    Default = "100%",
    Text = "DPI Scale",
    Callback = function(Value)
        Value = Value:gsub("%%", "")
        local DPI = tonumber(Value)
        Library:SetDPIScale(DPI)
    end,
})

MenuGroup:AddDivider()

MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", {
    Default = "RightShift",
    NoUI = true,
    Text = "Menu keybind"
})

MenuGroup:AddButton("Unload", function()
    Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("MyScriptHub")
SaveManager:SetFolder("MyScriptHub/specific-game")
SaveManager:SetSubFolder("specific-place")

SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])

SaveManager:LoadAutoloadConfig()
